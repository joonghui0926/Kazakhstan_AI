import sensor, image, time, math, lcd
from maix import KPU
from machine import Timer,PWM
from maix import GPIO
from fpioa_manager import fm
import gc
gc.collect()  # 메모리 해제


#버튼 핀 설정
fm.register(9, fm.fpioa.GPIO0, force=True)
fm.register(12, fm.fpioa.GPIO1, force=True)
fm.register(8, fm.fpioa.GPIO2, force=True)

button_1 = GPIO(GPIO.GPIO0, GPIO.IN, GPIO.PULL_UP)
button_2 = GPIO(GPIO.GPIO1, GPIO.IN, GPIO.PULL_UP)
button_3 = GPIO(GPIO.GPIO2, GPIO.IN, GPIO.PULL_UP)

#모터 핀 설정
tim0 = Timer(Timer.TIMER0, Timer.CHANNEL0, mode=Timer.MODE_PWM)
tim1 = Timer(Timer.TIMER0, Timer.CHANNEL1, mode=Timer.MODE_PWM)
tim2 = Timer(Timer.TIMER0, Timer.CHANNEL2, mode=Timer.MODE_PWM)
tim3 = Timer(Timer.TIMER0, Timer.CHANNEL3, mode=Timer.MODE_PWM)

l_motor_ib = PWM(tim0, freq=1000, duty=0, pin=19)
l_motor_ia = PWM(tim1, freq=1000, duty=0, pin=13)
r_motor_ib = PWM(tim2, freq=1000, duty=0, pin=17)
r_motor_ia = PWM(tim3, freq=1000, duty=0, pin=10)

#자동차 이동 함수 정의
def car_go(speed):
    r_motor_ib.duty(0)
    r_motor_ia.duty(speed)

    l_motor_ib.duty(speed)
    l_motor_ia.duty(0)

def car_back(speed):
    r_motor_ib.duty(speed)
    r_motor_ia.duty(0)

    l_motor_ib.duty(0)
    l_motor_ia.duty(speed)

def car_left(speed):
    r_motor_ib.duty(0)
    r_motor_ia.duty(speed)

    l_motor_ib.duty(0)
    l_motor_ia.duty(0)

def car_right(speed):
    r_motor_ib.duty(0)
    r_motor_ia.duty(0)

    l_motor_ib.duty(speed)
    l_motor_ia.duty(0)

def car_turn_left(speed):
    r_motor_ib.duty(0)
    r_motor_ia.duty(speed)

    l_motor_ib.duty(0)
    l_motor_ia.duty(speed)

def car_turn_right(speed):
    r_motor_ib.duty(speed)
    r_motor_ia.duty(0)

    l_motor_ib.duty(speed)
    l_motor_ia.duty(0)

#카메라 초기화
sensor.reset()
sensor.set_vflip(1)
sensor.set_pixformat(sensor.RGB565)
sensor.set_framesize(sensor.QVGA)
sensor.skip_frames(time=2000)

# LCD 디스플레이 초기화
lcd.init()
clock = time.clock()

# 검은 선을 추적합니다. (흰색 선을 추적하려면 [(128, 255)]를 사용합니다.)
GRAYSCALE_THRESHOLD = [(0, 64)]

ROIS = [
        (0, 100, 160, 20, 0.7),
        (0,  50, 160, 20, 0.3),
        (0,   0, 160, 20, 0.1)
       ]

weight_sum = 0
for r in ROIS:
    weight_sum += r[4]


#객체 인식
od_img = image.Image(size=(320,256))  # 320x256 크기의 이미지 객체 초기화

# 객체 이름 및 앵커 정의
obj_name = ("aeroplane",
            "bicycle",
            "bird",
            "boat",
            "bottle",
            "bus",
            "car",
            "cat",
            "chair",
            "cow",
            "diningtable",
            "dog","horse",
            "motorbike",
            "person",
            "pottedplant",
            "sheep","sofa",
            "train",
            "tvmonitor")
anchor = (1.3221, 1.73145, 3.19275, 4.00944, 5.05587, 8.09892, 9.47112, 4.84053, 11.2364, 10.0071)

# 모델 로드
kpu = KPU()
kpu.load_kmodel("/sd/model/voc20_detect.kmodel")

# YOLO2 초기화
kpu.init_yolo2(anchor, anchor_num=5, img_w=320, img_h=240, net_w=320 , net_h=256 ,layer_w=10 ,layer_h=8, threshold=0.5, nms_value=0.2, classes=20)

car_go_stop = "stop"
while(True):
    img = sensor.snapshot()

    #차선 자율주행 이미지 설정
    trac_img = img.resize(160, 120)
    trac_img = trac_img.to_grayscale()

    #인공지능 객체 인식
    od_img.draw_image(img, 0,0)     # 이미지를 od_img 이미지의 (0,0) 위치에 그립니다.
    od_img.pix_to_ai()                  # rgb565 이미지를 AI 연산에 필요한 r8g8b8 형식으로 변환
    kpu.run_with_output(od_img)         # 입력 이미지에 KPU 연산 수행
    dect = kpu.regionlayer_yolo2()      # YOLO2 후 처리

    #인공지능 객체 인식
    if len(dect) > 0:
        print("dect:",dect)
        for l in dect :
            img.draw_rectangle(l[0],l[1],l[2],l[3], color=(0, 255, 0))
            img.draw_string(l[0],l[1], obj_name[l[4]], color=(0, 255, 0), scale=1.5)
            if obj_name[l[4]] == "person":
                car_go_stop = "stop"

    #차선 자율주행
    centroid_sum = 0
    for r in ROIS:
        blobs = trac_img.find_blobs(GRAYSCALE_THRESHOLD, roi=r[0:4], merge=True)
        if blobs:
            largest_blob = max(blobs, key=lambda b: b.pixels())
            centroid_sum += largest_blob.cx() * r[4] # r[4]는 ROI 가중치입니다.

    center_pos = (centroid_sum / weight_sum) # 선의 중심을 결정합니다.
    #print("center_pos:",center_pos)

    # 각도 계산.
    deflection_angle = 0
    deflection_angle = -math.atan((center_pos-80)/60)
    deflection_angle = math.degrees(deflection_angle)

    if button_2.value() == 0:
        car_go_stop = "go"
    elif button_1.value() == 0 or button_3.value() == 0:
        car_go_stop = "stop"

    if car_go_stop == "go":
        img.draw_string(10, 100, "button1 or 3 click stop",color=(0,0,255),scale=1)
        if deflection_angle >= 30:
            print("right")
            img.draw_string(10, 10, "right",color=(0,0,255),scale=2)
            car_right(40)
        elif deflection_angle <= -30:
            print("left")
            img.draw_string(10, 10, "left",color=(0,0,255),scale=2)
            car_left(40)
        else:
            print("go")
            img.draw_string(10, 10, "go",color=(0,0,255),scale=2)
            car_go(40)
    else:
        img.draw_string(10, 100, "button2 click start",color=(0,0,255),scale=1)
        car_go(0)

    fps = clock.fps()                   # FPS 가져오기
    lcd.display(img)
    gc.collect()


# 각도를 바탕으로 이동방향 결정하기
